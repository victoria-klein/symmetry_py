import numpy as np
import sympy as sp
import itertools
import time as time

from internal import *
from built_ins import *
from head import *
from sugar import *
from criteria import *
from grob_helpers import *

#-------------------------------------------------------------#
# FUNCTIONS FOR MGH
#-------------------------------------------------------------#

def MGH_addpairs(k,P,memberP,superfluous,LCMHT,sugarIJ,HT,Sugar,X,to,bugfix,statistics,grads,W):
    """
    Input:
    k: index int
    P: set of possible SymPy polynomials
    memberP: symmetric dict
    superfluous: set
    LCMHT: dict
    sugarIJ: dict
    HT: leading monomial term of each SymPy polynomials
    Sugar: list of sugar degree of each SymPy polynomial
    X: list of vars SymPy symbols
    to: dict of term order
    bugfix: symmetric dict
    statistics: dict
    grads: list of gradings
    W: list of gradings

    Output:
    newP: updated set of possible SymPy polynomials 
    """
    # print(k,len(LCMHT),len(memberP),len(HT))
    neupairs, LCMHT, memberP, statistics = newpairs(k,HT,superfluous,LCMHT,X,memberP,statistics,*grads)
    # print('newpairs done')
    newP, statistics, memberP = criteria2proper(P,k,LCMHT,memberP,bugfix,statistics)
    # print('criteria2proper done')
    neupairs, memberP, statistics = criteria2a(k,neupairs,HT,LCMHT,memberP,bugfix,statistics)
    # print('criteria2a done')
    for IK in neupairs:
        sugarIJ[*IK] = sugarSpol(IK,LCMHT,X,HT,Sugar)
    # print('sugarSpol done')
    neupairs = [list(pair) for pair in neupairs]
    ### fuzzy variant
    neupairs = sort_internal(neupairs,MGH_strategy,LCMHT,sugarIJ,bugfix,to,X,W)
    neupairs2b, statistics, memberP = criteria2b(k,neupairs,LCMHT,memberP,bugfix,statistics)
    newP = merge_internal(newP,neupairs2b,MGH_strategy,LCMHT,sugarIJ,bugfix,to,X,W)
    return newP, LCMHT, memberP, statistics, sugarIJ
    
def MGH_discard(P,memberP,bugfix,LCMHT,W,X,d,statistics):
    """
    Input:
    P: set of possible SymPy polynomial pairs
    memberP: symmetric dict
    bugfix: symmetric dict
    LCMHT: dict
    W: list of gradings
    X: list of vars SymPy symbols
    d: list of degrees
    statistics: dict
    
    Output:
    P: without k pairs disregarded
    memberP, statistics: updated
    """
    if len(P) == 0:
        return []
    k = 0
    dd = MGH_multideg(LCMHT[*bugfix[*P[0]]],X,W[:len(d)])
    while MGH_multideggreatprop(d,dd):
        k += 1
        if k<len(P):
            dd = MGH_multideg(LCMHT[*bugfix[*P[k]]],X,W[:len(d)])
        else:
            break
    for l in range(1,k+1):
        memberP[*bugfix[*P[l-1]]] = 'finished'
    print('MGH_discard: ',k,' elements discarded using Hilbert series.')
    statistics['hilbertseries'] = k + statistics['hilbertseries']
    if k == len(P):
        return [], memberP, statistics
    else:
        return P[k:], memberP, statistics
    
def MGH_fullHP(H,zvars,s):
    """
    Input:
    H: Hilbert series
    zvars: list of variables of Hilbert series
    s: No. of gradings in minimal weight system
    
    Output
    hp: H where some gradings are dropped (substitution of 1 for zvars in H)
    """
    hp = [H]
    hs = H
    for j in range(len(zvars)-s):
        hs = subs((zvars[len(zvars)-1-j],1),hs)
        hp = [hs] + hp
    return hp
    
def MGH_initstatistics():
    """
    Output:
    statistics: initial dict for Hilbert series driven Groebner basis
    """
    statistics = {}
    statistics['crit2a'] = 0
    statistics['crit2b'] = 0
    statistics['crit2p'] = 0
    statistics['pairs'] = 0
    statistics['respairs'] = 0
    statistics['crit3'] = 0
    statistics['hilbertseries'] = 0
    return statistics
    
def MGH_multideg(m,vs,W):
    """
    Input:
    m: Sympy monomial m
    vs: list of SymPy symbols variables
    W: list of gradings forming weight system

    Output:
    Hilbert series of ideal generated by monomials m up to degree d
    """
    return [degree_internal(m,vs,elem) for elem in W]
    
def MGH_multideggreatprop(d,dd):
    """
    Input:
    d: list of degrees
    dd: list of degrees

    Output:
    True if first distinct element of d greater than dd, False otherwise
    """
    if len(d)==0 or len(dd)==0:
        return False
    if len(d)==1:
        return d[0]>dd[0]
    if d[0] > dd[0]:
        return True
    elif d[0] == dd[0]: 
        return MGH_multideggreatprop(d[1:],dd[1:])
    else:
        return False
    
def MGH_nrgradsinweight(W,X):
    """
    Input:
    W: list of gradings forming a weight system
    X: list of SymPy symbols variables

    Output:
    s: minimal no. of gradings in W s.t. first s gradings form weight system
    """
    s = 0
    flagweight = False
    while not(flagweight):
        s += 1
        flagweight = True
        for j in range(len(X)):
            flag = False
            for k in range(s):
                grading = W[k]
                if grading[str(X[j])] > 0:
                    flag = True
            if not(flag):
                flagweight = False
                break
    return s
    
def MGH_printstatistic(statistics,stt):
    """
    Input:
    statistics: dict
    stt: time

    Output:
    None
    """
    print('MGH_printstatistic: statistics:')
    print('Total number of treated pairs: ',statistics['pairs'])
    print('Pairs not treated wrt restriction: ',statistics['respairs'])
    print('Pairs eliminated because criteria: ', statistics['crit2a']+ statistics['crit2b']+ statistics['crit2p']+statistics['crit3'],
        '= ',statistics['crit2a'],'+',statistics['crit2b'],'+',statistics['crit2p'],'+',statistics['crit3'])
    print('Pairs eliminated wg Hilbert series: ',statistics['hilbertseries'])
    print('Time: ',time.time()-stt)
    
def MGH_select(HT,ws):
    """
    Input:
    HT: list of head terms of SymPy polynomials
    ws: list of SymPy symbols variables of roots

    Output:
    ht: HT where roots/ws in head terms are removed
    """
    ht = []
    for j in range(len(HT)):
        if len(intersect(indets(HT[j]),set(ws))) != 0:
            p = HT[j]
            for w in ws:
                while degree(p,w)>0:
                    p = p/w
            if p!=1:
                ht.append(p)
        else:
            ht.append(HT[j])
    return ht
    
def MGH_strategy(IJ,KL,LCMHT,sugarIJ,bugfix,termorder,X,W):
    """
    Input:
    IJ: pair of ints
    KL: pair of ints
    LCMHT: dict
    sugarIJ: dict
    bugfix: symmetric dict
    termorder: term order
    X: list of SymPy symbols variabless including roots
    W: list of gradings forming weight system

    Output:
    True if IJ and KL meet MGH selection strategy, False if not
    """
    for j in range(len(W)):
        d1 = degree_internal(LCMHT[*bugfix[*IJ]],X,W[j])
        d2 = degree_internal(LCMHT[*bugfix[*KL]],X,W[j])
        if d1>d2:
            return False
        if d1<d2:
            return True
    s1 = sugarIJ[*bugfix[*IJ]]
    s2 = sugarIJ[*bugfix[*KL]]
    flag, q = issugargreater(s1,s2,'q')
    if q: 
    #   lcmIJ:=LCMHT[op(bugfix[op(IJ)])];
    #   lcmKL:=LCMHT[op(bugfix[op(KL)])];
    #   if lcmIJ=lcmKL then 
    #     if IJ[2]< KL[2] then RETURN(true) else RETURN(false) fi;
    #   fi;
    #   if `moregroebner/src/internal/isgreaterorder2`(lcmIJ, lcmKL, termorder) then
    #      RETURN(false) else RETURN(true) fi;
        return normal_strategy(IJ,KL,LCMHT,bugfix,termorder)
    return not(flag)

def MGH_tentHP(monoms,vs,W):
    """
    Input:
    monoms: list of SymPy monomials
    vs: list of SymPy symbols variables
    W: lsit of gradings forming a weight system

    Output:
    Hilbert series of ideal generated by monomials
    """
    zvars = [elem['_Hseriesvar'] for elem in W]
    return HP(monoms,vs,indets(monoms),W,zvars)
    
def MGH_tentativeHP(monoms,vs,W,s,d,hps):
    """
    Input:
    monoms: list of SymPy monomials
    vs: list of SymPy symbols variables
    W: lsit of gradings forming a weight system
    s:
    d: degree
    hps:

    Output:
    Hilbert series of ideal generated by monomials up to degree d
    """

    if s == len(W):
        return [hps]
    mms = []
    for m in monoms:
        md = MGH_multideg(m,vs,W[:s])
        if MGH_multideglesseq(md,d):
            mms.append(m)
    zvars = [elem['_Hseriesvar'] for elem in W]
    HP = HP(mms,vs,indets(mms),W,zvars)
    HP = MGH_fullHP(HP,zvars,s)
    print('MGH_tentativeHP: New Hilbert series ',HP,'.')
    return HP

def MGH_multideglesseq(d, dd):
    """
    Input:
    d: list of degrees
    dd: list of degrees

    Output:
    True if first distinct element of d less than dd, False otherwise
    """
    if len(d)==0:
        return True
    if d[0]<dd[0]:
        return True
    elif d[0]==dd[0]: 
        return MGH_multideglesseq(d[1:],dd[1:])
    else:
        return False

def MGH_Einit(EE,HP,tHP,zvars,d1sold):
    """
    EE: dict
    HP: Hilbert series
    tHP: tentative Hilbert series
    zvars: list of SymPy symbols variables of Hilbert series
    d1sold: list of degrees
    
    Output:
    ds: first degree for which dimensions in HP and tHP differ
    """
    hp = normal(-HP+tHP)
    ds = []
    s = EE['_s']
    for j in range(1,EE['_s']+1):
        if d1sold[:j-1] == ds[:j-1]:
            k = d1sold[j-1]
        else:
            k = 0
        ss = series(hp,(zvars[j-1],0),k+1).removeO()
        ss = coeff(sp.collect(ss,zvars[j-1]),zvars[j-1],k)
        while ss == 0:
            k = k+1
            ss = series(hp,(zvars[j-1],0),k+1).removeO()
            ss = coeff(sp.collect(ss,zvars[j-1]),zvars[j-1],k)
        hp = ss
        ds.append(k)
    EE['_d1s'] = ds
    EE['ds'] = ss
    print('MGH_Einit: Minimal degree ',ds,'.')
    return ds, EE

def MGH_Eclean(EE,d):
    """
    Input:
    EE: dict
    d: list of degrees

    Output:
    EE: keys in d removed
    """
    s = EE['_s']
    del EE[d] #= evaln(EE[d])
    vals = [len(d)-1-j for j in range(0,len(d)-1-EE['_s'])]
    for j in vals:
        del EE[d[:j],'polynom'] #:=evaln(EE[[d[1..j]],polynom]);
        del EE[d[:j]] #:=evaln(EE[[d[1..j]]]);
    return EE

#------------------------------------------------------------------------------#
# E = table([d_1,..d_s] = a, [d_1,..d_s,d_s+1] = b, [d_1,..d_s,d_s+1'] =c ..
#------------------------------------------------------------------------------#
def MGH_Eupdate(EE,HP,tHP,zvars,d,flagd1s,flagda):
    """
    Input:
    EE: dict containing dimensions of homogeneous vector spaces as required in MGHdriven Buchberger algorithm
    HP: Hilbert series
    tHP: tentative Hilbert series
    zvars: list of SymPy symbols variables of Hilbert series
    d: list of ints
    flagd1s: string
    flagda: string

    Output:
    EE: updated
    flagd1s: string
    flagda: string
    """
    flagd1s = False
    flagda = False
    flag = False
    s = EE['_s']
    r = EE['_r']
# normal case
    vals = [EE['_r']-j for j in range(0,EE['_r']-EE['_s'])]
    for k in vals:
        dd = d[:k]
        EE[dd] = EE[dd]-1
        if EE[dd] == 0: 
            flagda = True
            flag = True
            del EE[dd] #:= evaln(EE[dd]);
            del EE[dd,'polynom'] #:= evaln(EE[dd,polynom]);
            print('MGH_Eupdate: Degree ',dd,' finished.')
            if k == EE['_s']:
                flagd1s = True
                flag = False
            jb = k
        else:
            print('MGH_Eupdate: At degree ',dd,' remaining dimension ',EE[dd],'.')
# bad update case necessary
    if flag: # update dimension
        print('MGH_Eupdate: Updating structure EE because dim. zero.')
        flag, EE = MGH_Enextdegdim(EE,HP,tHP,zvars,d[:jb-1] + [d[jb]+1] + [0 for i in range(r-jb)],jb,'flag')
        if flag:
            flagd1s = True
    return EE, flagd1s, flagda

def MGH_Enextdegdim(EE,HPlist,HPtentlist,zvars,dakt,jb,flag):
    """
    Input:
    EE: dict containing dimensions of homogeneous vector spaces
    HPlist: list of Hilbert series of ideals, first for weight system, then for w1,..,w_s+1 etc.
    HPtentlist: list of tentative Hilbert series of Groebner bases so far
    zvars: list of SymPy symbols variables of Hilbert series
    dakt: [d1,..d_s,d_s+1,..] aktuell degree
    jb: int
    flag: string

    Output:
    flag:
    """
    da = dakt
    flag = False
    iflag = False
    s = EE['_s']
    r = EE['_r']
    mindeg = EE['_d1s']
    if MGH_multideggreatprop(da[:s],mindeg):
        flag = True
        return flag, EE
    j = jb
    while j <= r:
        if j <= s:
            flag = True
            iflag = True
            print('MGH_Enextdegdim: Degree ',EE['_d1s'],' finished.')
            break
        if 'polynom' in EE[mindeg[:j-1]].keys():
            mt = EE[mindeg[:j-1],'polynom']
        else:
            if j-1 == 1: 
                mt = series(-HPlist[j-s+1]+HPtentlist[j-s+1],zvars[0],mindeg[0]+1)
                mt = convert(mt,'polynom')
            else:
                mt = mtaylor(-HPlist[j-s+1]+HPtentlist[j-s+1],zvars[:j-1],convert(mindeg[:j-1],'+')+1)
            for nu in range(j-1):
                mt = coeff(sp.collect(mt,zvars[nu]),zvars[nu],mindeg[nu])
            mt = sp.collect(mt,zvars[j])
            EE[mindeg[:j-1],'polynom'] = mt
        if [da[:j-1]] == [mindeg[:j-1]]:
            deg = da[j]
        else:
            deg = 0
        if deg > degree(mt,zvars[j]):
            da = da[:j-2] + [da[j-1]+1] + [0 for nu in range(r-j)]
            del EE[mindeg[:j-1],'polynom'] #:=evaln(EE[mindeg[1..j-1],polynom]);
            del EE[mindeg[:j-1]] #:=evaln(EE[mindeg[1..j-1]]);
            mindeg = mindeg[:j-1]
            j -= 1
        else:
            dim = coeff(mt,zvars[j],deg)
            while dim == 0:
                deg += 1
                dim = coeff(mt,zvars[j],deg)
            mindeg = mindeg[1..j-1] + [deg]
            EE[mindeg] = dim
            j += 1
    if EE['_r'] > EE['_s'] and not(iflag):
        print('MGH_Enextdegdim: Aktuell degree ',mindeg,' with dim. ',EE[mindeg],'.')
    EE['_da'] = mindeg
    return flag, EE

def mtaylor(function_expression, variable_list, degree):
    # https://math.libretexts.org/Bookshelves/Calculus/Supplemental_Modules_(Calculus)/Multivariable_Calculus/3%3A_Topics_in_Partial_Derivatives/Taylor__Polynomials_of_Functions_of_Two_Variables
    """
    Mathematical formulation reference:
    function_expression: Sympy expression of the function
    variable_list: list of variables to be approximated (to be "Taylorized")
    degree: int of total degree of the Taylor polynomial

    Output:
    polynomial: multivariate Taylor series up to degree d, of a given multivariate expression
    """
    n_var = len(variable_list)
    evaluation_point = [0 for i in range(n_var)]
    point_coordinates = [(i, j) for i, j in (zip(variable_list, evaluation_point))]  # list of tuples with variables and their evaluation_point coordinates, to later perform substitution

    deriv_orders = list(itertools.product(range(degree + 1), repeat=n_var))  # list with exponentials of the partial derivatives
    deriv_orders = [deriv_orders[i] for i in range(len(deriv_orders)) if sum(deriv_orders[i]) <= degree]  # Discarding some higher-order terms
    n_terms = len(deriv_orders)
    deriv_orders_as_input = [list(sum(list(zip(variable_list, deriv_orders[i])), ())) for i in range(n_terms)]  # Individual degree of each partial derivative, of each term

    polynomial = 0
    for i in range(n_terms):
        partial_derivatives_at_point = function_expression.diff(*deriv_orders_as_input[i]).subs(point_coordinates)  # e.g. df/(dx*dy**2)
        denominator = sp.prod([sp.factorial(j) for j in deriv_orders[i]])  # e.g. (1! * 2!)
        distances_powered = sp.prod([(sp.Matrix(variable_list) - sp.Matrix(evaluation_point))[j] ** deriv_orders[i][j] for j in range(n_var)])  # e.g. (x-x0)*(y-y0)**2
        polynomial += partial_derivatives_at_point / denominator * distances_powered
    return polynomial